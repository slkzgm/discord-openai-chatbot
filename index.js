const fs = require('node:fs');
const path = require('node:path');
const { Client, Collection, Events, GatewayIntentBits } = require('discord.js');
const { answerConversation } = require("./openai");
const connectDB = require('./database/connection');
require('dotenv').config();

// TODO:
// - Retirer le fait qu'elle soit trop bavarde (eviter de relancer la conv pour rien)
// - Apprendre le lore du personnage
// - Utiliser la fonction pour les ticks
// - Fine-Tune SW et siege

// Cr√©ation du client Discord
const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent
    ]
});
client.commands = new Collection();

const foldersPath = path.join(__dirname, 'commands');
const commandFolders = fs.readdirSync(foldersPath);

for (const folder of commandFolders) {
    const commandsPath = path.join(foldersPath, folder);
    const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));
    for (const file of commandFiles) {
        const filePath = path.join(commandsPath, file);
        const command = require(filePath);
        // Set a new item in the Collection with the key as the command name and the value as the exported module
        if ('data' in command && 'execute' in command) {
            client.commands.set(command.data.name, command);
        } else {
            console.log(`[WARNING] The command at ${filePath} is missing a required "data" or "execute" property.`);
        }
    }
}

// Variations des messages
const responses = {
    thanks: [
        "Content d'avoir pu √©clairer ta lanterne, √† bient√¥t !",
        "Toujours dispo pour aider, tu sais o√π me trouver !",
        "√áa me fait plaisir de rendre service, √† la prochaine !",
        "Bon, mission accomplie, je me retire en silence üòé",
        "Heureux d‚Äôavoir pu participer, on se revoit bient√¥t j‚Äôesp√®re !",
        "Je m‚Äôenvole vers d'autres aventures. √Ä la prochaine ! ü¶∏‚Äç‚ôÇÔ∏è",
        "Si t‚Äôas encore besoin, tu sais o√π cliquer, hein üòâ",
        "Content de t‚Äôavoir aid√©, mais c‚Äôest l‚Äôheure pour moi de briller ailleurs ‚ú®",
        "Eh bien, je suppose que c‚Äôest tout pour moi, allez ciao !",
        "Une aide de qualit√©, c‚Äôest tout naturel avec moi üòè",
        "Ravi d‚Äôavoir pu vous assister, cher ami. Au plaisir !",
        "Je disparais dans les ombres‚Ä¶ enfin, jusqu‚Äô√† la prochaine question !",
        "Allez, un plaisir comme d‚Äôhab, on se capte plus tard !",
        "H√©, c‚Äôest toujours un honneur d‚Äôaider. √Ä bient√¥t, bande de geeks !",
        "Le bot est mort, vive le bot ! √Ä la prochaine fois üòâ",
        "Avec un peu de runes et de chance, on arrive √† tout ! √Ä bient√¥t les invocateurs !",
        "Content d'avoir boost√© ton niveau, on se recroise bient√¥t sur l'ar√®ne !",
        "C‚Äô√©tait aussi efficace qu‚Äôun combo bien plac√© dans Summoners War. √Ä plus tard !",
        "Toujours l√† pour filer un coup de main, comme un bon support en ar√®ne !",
        "T‚Äôas g√©r√© comme un h√©ros de shonen, maintenant go farmer des donjons !",
        "Bon, t‚Äôes pr√™t pour ton prochain √©veil ? √Ä la prochaine invocation !",
        "Aide termin√©e, on se revoit apr√®s ton prochain scroll mystique !",
        "Je suis pas un personnage 5 √©toiles, mais je fais le taf üòâ",
        "Ravi d‚Äôavoir pu t‚Äô√©pauler, maintenant go grinder ces runes !",
        "Comme un bon vieux power-up d‚Äôanime, j‚Äôai fait mon taf. √Ä la revoyure !",
        "Ouais, t'as ma√Ætris√© cette question comme un pro d'ar√®ne. √Ä bient√¥t pour un duel !",
        "Heureux d‚Äôavoir aid√©, maintenant farm les gemmes !",
        "Mission accomplie, j'suis pr√™t pour le prochain challenge. √Ä plus dans le Rift !",
        "Bon, t‚Äôas maintenant toutes les cartes en main. Pr√™t pour l‚Äôar√®ne ?",
        "C‚Äô√©tait aussi satisfaisant qu‚Äôun ultimate bien plac√©. √Ä plus tard !"
    ],
    tooMuchTalking: [
        "Wouah, trop de blabla, j‚Äôai besoin d‚Äôune pause l√† üò¥",
        "Ouh l√†, √ßa devient intense, je vais prendre du recul !",
        "Vous √™tes bavards, je me retire avant que √ßa devienne trop s√©rieux.",
        "Eh oh, je vais finir par surchauffer avec tout √ßa, peace out !",
        "Trop de mots, trop d'infos, j'abandonne üòµ",
        "Vous parlez autant que des conf√©renciers, je vous laisse entre pros üòú",
        "Bon, trop de discussions, je vais prendre une sieste !",
        "Je vous laisse, vous √™tes en pleine conf√©rence TED l√† ou quoi ?",
        "Oubliez pas de respirer entre deux phrases hein !",
        "Vous d√©battez comme des philosophes. Moi, je sors du game !",
        "Bon, c‚Äôest bien beau, mais l√†, je m‚Äô√©clipse avant l‚Äôexplosion neuronale !",
        "Hey, je vous laisse entre bavards, moi je vais regarder des m√®mes.",
        "Vous avez trop de choses √† dire, moi j‚Äôarr√™te l√† !",
        "Je vous laisse papoter, moi j‚Äôai besoin d‚Äôun caf√© ‚òï",
        "Ok ok, j'abandonne, trop de dialogue pour moi, bye les intellos !",
        "Ok ok, je m‚Äô√©clipse avant qu‚Äôon se retrouve dans un d√©bat digne de One Piece üòÖ",
        "√áa commence √† ressembler √† un √©pisode filler, je vais farm mes runes ailleurs !",
        "Vous parlez plus qu‚Äôun shonen en plein arc narratif, je prends la tangente !",
        "C‚Äôest pire qu‚Äôun GvG tendu l√†, je vais prendre un break !",
        "On dirait une discussion de fin de saison d‚Äôanime, je vais me poser un peu !",
        "C‚Äôest devenu plus intense qu‚Äôun combat contre un boss de raid, je me casse !",
        "Trop de blabla, je vais invoquer du calme ailleurs. √Ä plus !",
        "Oulah, √ßa devient plus long qu‚Äôun √©pisode de Hunter x Hunter. Break time !",
        "On dirait un arc narratif qui ne finit jamais, je prends la porte !",
        "Je vais pas faire un AFK comme dans Summoners War, mais je vous laisse discuter !",
        "Vous √™tes plus longs que l'attente entre deux events, moi je vais en ar√®ne !",
        "Trop de strats et pas assez d‚Äôaction, je me d√©connecte avant l‚Äôoverload !",
        "Vous √™tes plus bavards qu‚Äôun h√©ros de shonen en plein discours !",
        "Je pensais √™tre dans une ar√®ne, mais l√† c'est un marathon de paroles. Pause time !",
        "Vous g√©rez la conversation comme un boss de raid, mais l√† je sature. √Ä plus !"
    ]
};

// S√©lectionner un message al√©atoire
function getRandomResponse(category) {
    const messages = responses[category];
    return messages[Math.floor(Math.random() * messages.length)];
}

let groupConversations = {}; // Pour g√©rer plusieurs conversations par channel
let tokensUsed = {};
let resetTimeouts = {};
const HISTORY_LIMIT = 15;
const MAX_TOKENS = 10000;
let MAX_MESSAGES_NO_RESPONSE = 50; // Nombre de messages sans que le bot ne soit mentionn√©
let RESET_TIMEOUT = 300000; // 5 minutes d'inactivit√© avant de r√©initialiser la conversation

async function answer(message, channelId) {
    await message.channel.sendTyping();

    // V√©rifie si quelqu'un remercie ou cl√¥ture la conversation
    if (message.content.toLowerCase().includes("merci")
        || message.content.toLowerCase().includes("c'est tout")
        || message.content.toLowerCase().includes("cimer")
    ) {
        await message.reply(getRandomResponse('thanks'));
        resetConversation(channelId); // R√©initialise la conversation sur un merci ou c'est tout
        return;
    }

    try {
        await message.channel.sendTyping();
        const response = await answerConversation(groupConversations[channelId]);
        const botResponse = response.choices[0].message.content.trim();

        groupConversations[channelId].push({
            role: 'assistant',
            content: botResponse
        });

        tokensUsed[channelId] += response.usage.total_tokens;

        await message.channel.send(botResponse);
        if (tokensUsed[channelId] >= MAX_TOKENS) {
            await message.channel.send(getRandomResponse('tooMuchTalking'));
            resetConversation(channelId); // R√©initialise la conversation
        }
    } catch (error) {
        console.error("Erreur lors de l'appel √† l'API OpenAI :", error);
        await message.reply("D√©sol√©, une erreur s'est produite.");
        resetConversation(channelId); // R√©initialise la conversation en cas d'erreur
    }
}

// Timer de r√©initialisation apr√®s un certain d√©lai (X minutes)
function startResetTimeout(channelId) {
    if (resetTimeouts[channelId]) {
        clearTimeout(resetTimeouts[channelId]);
    }

    resetTimeouts[channelId] = setTimeout(() => {
        const lastMessage = groupConversations[channelId][groupConversations[channelId].length - 1];
        // Ne r√©initialise que si le dernier message n'est pas du bot ET que le d√©lai d'inactivit√© est d√©pass√©
        if (lastMessage.role !== 'assistant') {
            resetConversation(channelId); // R√©initialise la conversation apr√®s X minutes d'inactivit√©
        }
    }, RESET_TIMEOUT); // 5 minutes d'inactivit√©
}

function resetConversation(channelId) {
    groupConversations[channelId] = [];
    tokensUsed[channelId] = 0;
    clearTimeout(resetTimeouts[channelId]);
}

client.once('ready', async () => {
    await connectDB();
    console.log(`Connect√© en tant que ${client.user.tag}`);
});

client.on('messageCreate', async (message) => {
    if (message.author.bot) return;
    const channelId = message.channel.id; // Utilise l'ID du channel pour g√©rer plusieurs conversations

    // V√©rifie si le bot est mentionn√©
    if (message.mentions.has(client.user)) {
        // Si la conversation n'existe pas encore
        if (!groupConversations[channelId] || !groupConversations[channelId].length) {
            // Initialiser la conversation et le nombre de tokens utilis√©s
            groupConversations[channelId] = [];
            tokensUsed[channelId] = 0;

            // R√©cup√©rer l'historique des messages pr√©c√©dents pour le contexte
            const history = await message.channel.messages.fetch({ limit: HISTORY_LIMIT });
            history.reverse().forEach(msg => {
                groupConversations[channelId].push({
                    role: 'user',
                    content: `${msg.author.globalName}: ${msg.content}`
                });
            });
        } else { // Si la conversation est deja active
            groupConversations[channelId].push({
                role: 'user',
                content: `${message.author.globalName}: ${message.content}`
            });
        }

        await answer(message, channelId);
        // startResponseTimeout(message, channelId); // D√©marre le d√©lai pour la r√©ponse automatique
        startResetTimeout(channelId); // D√©marre le d√©lai pour la r√©initialisation automatique
        return;
    }

    // Si la conversation existe et continue sans mention du bot, on r√©initialise le timer d'inactivit√©
    if (groupConversations[channelId] && groupConversations[channelId].length > 0) {
        groupConversations[channelId].push({
            role: 'user',
            content: `${message.author.globalName}: ${message.content}`
        });

        // startResponseTimeout(message, channelId); // Red√©marre le d√©lai pour la r√©ponse automatique
        startResetTimeout(channelId); // Red√©marre le d√©lai pour la r√©initialisation

        // Si le nombre de messages sans sollicitation d√©passe la limite, r√©initialise
        const assistantMessages = groupConversations[channelId].filter(msg => msg.role === 'assistant').length;
        if (groupConversations[channelId].length - assistantMessages >= MAX_MESSAGES_NO_RESPONSE) {
            resetConversation(channelId); // R√©initialise apr√®s trop de messages sans sollicitation
        }
    }
});

client.on(Events.InteractionCreate, async interaction => {
    if (!interaction.isChatInputCommand()) return;

    const command = interaction.client.commands.get(interaction.commandName);

    if (!command) {
        console.error(`No command matching ${interaction.commandName} was found.`);
        return;
    }

    try {
        await command.execute(interaction);
    } catch (error) {
        console.error(error);
        if (interaction.replied || interaction.deferred) {
            await interaction.followUp({ content: 'There was an error while executing this command!', ephemeral: true });
        } else {
            await interaction.reply({ content: 'There was an error while executing this command!', ephemeral: true });
        }
    }
});

// Connecte le bot √† Discord avec le token
client.login(process.env.DISCORD_TOKEN);